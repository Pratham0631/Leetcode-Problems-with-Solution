=> Reverse bits of a given 32 bits signed integer.

=> Example 1:

      Input: n = 43261596
      Output: 964176192

      Explanation:
        Integer	    Binary
        43261596	  00000010100101000001111010011100
        964176192	  00111001011110000010100101000000

=>  **Wrong Code**
    Because when n becomes == 0, and if it contains leading 0's then in reversal those 0's will be missed and cause miscalculation.
=>  public int reverseBits(int n) {
        if(n == 0) return 0;

        int res = 0;
        while(n != 0){
            res = res << 1;
            res = (n & 1) | res;
            n = n >> 1;
        }

        return res;
    }

=> **Correct Code**
here first do res << 1 because shifting it after res calc keeps 0 at the end of calc which causes error.

=> public int reverseBits(int n) {
        if(n == 0) return 0;

        int res = 0;
        for(int i = 1; i <= 32; i++){
            res = res << 1;
            res = ((n & 1) | res);
            n = n >> 1;
        }

        return res;
   }
