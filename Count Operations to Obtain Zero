2169. Count Operations to Obtain Zero:
    -> You are given two non-negative integers num1 and num2.
    -> In one operation, if num1 >= num2, you must subtract num2 from num1, otherwise subtract num1 from num2.
    -> For example, if num1 = 5 and num2 = 4, subtract num2 from num1, thus obtaining num1 = 1 and num2 = 4. However, if num1 = 4 and num2 = 5, after one operation, num1 = 4 and        num2 = 1.
    -> Return the number of operations required to make either num1 = 0 or num2 = 0.

    My Brute Force Approach: (Simple and Intuitive)
           public int countOperations(int num1, int num2) {
                int cntOpr = 0;
                while(num1 != 0 && num2 != 0){
                    cntOpr++;
                    if(num1 >= num2)
                        num1 = num1 - num2;
                    else
                        num2 = num2 - num1;
                }
                return cntOpr;
          }
          Time: O(max(num1, num2)) → inefficient for big numbers
          Space: O(1)

    Optimized Approach:
        Intuition -> 
            Above approach can perform too many subtractions when numbers are large and uneven (e.g. num1 = 1, num2 = 100000 → 100000 operations).
            * Subtracting num2 from num1 repeatedly until num1 < num2 is equivalent to doing it num1 // num2 times in one go. *

        public int countOperations(int num1, int num2) {
            if (num1 == 0 || num2 == 0) return 0;
            if (num1 < num2) return countOperations(num2, num1);
            return (num1 / num2) + countOperations(num1 % num2, num2);
        }
        Time: O(log(min(num1, num2)))
        Space: O(log(min(num1, num2))) (recursion depth)

        Example Dry Run:
            n1 = 100, n2 = 4
            (100, 4)
                25 + (0, 4) -> (4, 0)  // swap
                        return 0;

            n1 = 3, n2 = 2
            (3, 2)
                1 + (1, 2) -> (2, 1)  // swap
                        2 + (0, 1) -> (1, 0)
                                return 0;
        
            
